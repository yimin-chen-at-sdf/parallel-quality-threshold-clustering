#include <omp.h>
#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <getopt.h>

void PrintUsage()
{
    printf("To use this program, edit the first number in the command in the following line according to the size of your rmsd.dat file or equivalently the number of frames in your trajectory generated by molecular dynamics. ");
    printf("Next, edit the second number in the command in the following line according to your own needs and pay attention to the dimension or unit of the data stored in your rmsd.dat file. ");
    printf("Then, edit the name of the file which will store the output after calculation. ");
    printf("Finally, set the OMP_NUM_THREADS environment variable before typing the edited command.\n");
    printf("./parallelqt --number 1000 --threshold 0.42 --output clusteringresult.txt\n");
}

void* AllocIntArray (int rows, int cols)
{
    return malloc( sizeof(int[rows][cols]) );
}

void* AllocFloatArray (int rows, int cols)
{
    return malloc( sizeof(float[rows][cols]) );
}

/* This function uses a feature from C99. */
void ReadFloatArray (int rows, int cols, float array[rows][cols])
{
    FILE *data;
    data=fopen("rmsd.dat", "rb");
    if (data == NULL)
    {
        fprintf(stderr, "rmsd.dat does not exist!\n");
        exit(1);
    }
    fread(array, sizeof(float[rows][cols]), 1, data);
    fclose(data);
}

int **ConvertIntMatrix(int *a, int nrow, int ncol)
/* The routine should be called with the address &a[0][0] as the first argument.
*/
{
    int **m;
    m = (int **) malloc((size_t) ((nrow)*sizeof(int*)));
    if (m == NULL)
    {
        fprintf(stderr, "Memory allocation failure in ConvertIntMatrix().\n");
        exit(1);
    }
    m[0] = a;
    for (int i=1; i<nrow; i++)
        m[i] = m[i-1] + ncol;
    return m;
}

float **ConvertFloatMatrix(float *a, int nrow, int ncol)
/* The routine should be called with the address &a[0][0] as the first argument.
*/
{
    float **m;
    m = (float **) malloc((size_t) ((nrow)*sizeof(float*)));
    if (m == NULL)
    {
        fprintf(stderr, "Memory allocation failure in ConvertFloatMatrix().\n");
        exit(1);
    }
    m[0] = a;
    for (int i=1; i<nrow; i++)
        m[i] = m[i-1] + ncol;
    return m;
}

void FreeConvertIntMatrix(int **b)
/* free a matrix allocated by ConvertIntMatrix() */
{
    free((char*) b);
}

void FreeConvertFloatMatrix(float **b)
/* free a matrix allocated by ConvertFloatMatrix() */
{
    free((char*) b);
}

void SetBit (unsigned A[], int o)
{
    A[o/sizeof(unsigned)] |= 1 << (o%sizeof(unsigned));
}

int TestBit (unsigned A[], int o)
{
    return ( (A[o/sizeof(unsigned)] & (1 << (o%sizeof(unsigned)) )) != 0 );
}

/* frame is a compacted matrix. It stores the sequence numbers of elements that 
are within threshold towards each element. Its width is del. rmsd is a compacted
matrix. It stores the distances smaller than threshold according to the sequence
numbers. Its width is del. localframe can be viewed as a slice of frame where 
only elements assigned to one thread are included. It stores the sequence num-
bers of elements that are within threshold towards each element assigned to one 
thread. Its width is lmax. Before growing any candidate cluster, localrmsd can 
be viewed as slice of rmsd where distances are included if one edge of the dis-
tances belongs to elements assigned to one thread. During growing candidate 
clusters, it keeps updating since it stores the maximum value of distances from 
each element outside the candidate cluster to all elements in the candidate
cluster. Its width is lmax. The dense array index stores currently unclustered 
elements after each iteration. It remains unchanged during the execution of this
function. stack is a private variable. It is the number of assigned elements 
that acts as starting points of candidate clusters. start is the relative posi-
tion of the first element assigned to one thread inside all unclustered ele-
ments that acts as a starting point of certain candidate cluster, not the se-
quence number of that element. remainder is the number of elements that have not
been clustered. clusterbit is a private variable. It is a sparse bit-mask that 
contains one for elements that have been added to a growing candidate cluster 
and zero for other elements. clusterbitsize is the size of indexbit or clusterbi
t. The array outputnumber stores the sizes of candidate clusters, which can be 
viewed as the output of this function. */
void MultiClustering (int **frame, float **rmsd, int **localframe, float **restrict localrmsd, int *index, int stack, int start, int remainder, unsigned *restrict clusterbit, int clusterbitsize, int del, int lmax, int *restrict outputnumber)
{
    int cardinality, anchor, cancer, flag;
    float nominee;
    for (int l=0; l<stack; l++)
    {
        for (int m=0; m<clusterbitsize; m++)
        {
            clusterbit[m] = 0;
        }
        SetBit(clusterbit, index[l+start]);
/* Initialize the bit-mask clusterbit. */
        cardinality = 1;
        while (cardinality < remainder)
        {
            nominee = -1.0;
            for (int m=0; m<lmax; m++)
            {
                if (localframe[l][m] < 0)
                    break;
                if (TestBit(clusterbit, localframe[l][m]) == 0 && localrmsd[l][m] > 0.0)
                {
                    if (nominee < 0.0)
                    {
                        anchor = m;
                        nominee = localrmsd[l][m];
                    }
                    else
                    {
                        if (localrmsd[l][m] < nominee)
                        {
                            anchor = m;
                            nominee = localrmsd[l][m];
                        }
                    }
                }
            }
            if (nominee < 0.0)
                break;
            cardinality++;
            anchor = localframe[l][anchor];
/* Here anchor has been replaced with a sequence number of the element to be 
added to the candidate cluster. Obviously, anchor is different from index[l+star
t] for a given l. */
            SetBit(clusterbit, anchor);
            if (anchor < index[l+start] || anchor > index[start+stack-1])
            {
                for (int m=0; m<lmax; m++)
                {
                    if (localframe[l][m] < 0)
                        break;
                    if (TestBit(clusterbit, localframe[l][m]) != 0 || localrmsd[l][m] < 0.0)
                        continue;
                    cancer = -1;
                    for (int n=0; n<del; n++)
                    {
                        if (frame[anchor][n] < 0 || frame[anchor][n] > localframe[l][m])
                            break;
                        if (frame[anchor][n] == localframe[l][m])
                        {
                            cancer = n;
                            break;
                        }
                    }
                    if (cancer < 0)
                        localrmsd[l][m] = -1.0;
                    else
                    {
                        if (localrmsd[l][m] < rmsd[anchor][cancer])
                            localrmsd[l][m] = rmsd[anchor][cancer];
                    }
                }
            }
            else
            {
                for (int m=l+1; m<stack; m++)
                {
                    if (index[m+start] == anchor)
                    {
                        flag = m;
                        break;
                    }
                }
                for (int m=0; m<lmax; m++)
                {
                    if (localframe[l][m] < 0)
                        break;
                    if (TestBit(clusterbit, localframe[l][m]) != 0 || localrmsd[l][m] < 0.0)
                        continue;
                    cancer = -1;
                    for (int n=0; n<lmax; n++)
                    {
                        if (localframe[flag][n] < 0 || localframe[flag][n] > localframe[l][m])
                            break;
                        if (localframe[flag][n] == localframe[l][m])
                        {
                            cancer = n;
                            break;
                        }
                    }
                    if (cancer < 0)
                        localrmsd[l][m] = -1.0;
                    else
                    {
                        if (localrmsd[l][m] < localrmsd[flag][cancer])
                            localrmsd[l][m] = localrmsd[flag][cancer];
                    }
                }
            }
/* Update localrmsd. As long as an element is outside the candidate cluster, the
maximum value of distances from it to all elements in the candidate cluster in-
creases monotonously during the growing of the candidate cluster. After one ele-
ment was added to the candidate cluster, the maximum value of distances from one
element outside the candidate cluster to all elements in the candidate cluster 
should be the larger one between the distance from the element outside the can-
didate cluster to the latest member of the candidate cluster and the previous 
maximum value of distances from the element outside the candidate cluster to all
elements in the candidate cluster. */
        }
        outputnumber[l+start] = cardinality;
    }
}

/* frame is a compacted matrix. It stores the sequence numbers of elements that 
are within threshold towards each element. Its width is del. rmsd is a compacted
matrix. It stores the distances smaller than threshold according to the sequence
numbers. Its width is del. Before growing the candidate cluster assigned to this
thread, array diameter can be viewed as one line of rmsd. During growing the 
candidate cluster, diameter keeps updating since it stores the maximum value of 
distances from each element outside the candidate cluster to all elements in the
candidate cluster. It is a private variable here and its size is del. seqseed is
the sequence number of the element assigned to this thread inside all uncluster-
ed elements that acts as a starting point of the candidate cluster. indexbit is 
a sparse bit-mask that contains one for elements that have been clustered before
the current iteration and zero for other elements. It remains unchanged during 
the execution of this function. remainder is the number of elements that have 
not been clustered. clusterbit is a private variable. It is a sparse bit-mask 
that contains one for elements that have been added to the growing candidate 
cluster and zero for other elements. clusterbitsize is the size of indexbit or 
clusterbit.*/
int EndingClustering (int **frame, float **rmsd, int *shortidlist, float *restrict diameter, int seqseed, int remainder, unsigned *restrict clusterbit, int clusterbitsize, int del, int lmax)
{
    int cardinality, anchor, cancer;
    float nominee;
    for (int l=0; l<clusterbitsize; l++)
    {
        clusterbit[l] = 0;
    }
    SetBit(clusterbit, seqseed);
/* Initialize the bit-mask clusterbit. */
    cardinality = 1;
    while (cardinality < remainder)
    {
        nominee = -1.0;
        for (int l=0; l<lmax; l++)
        {
            if (TestBit(clusterbit, shortidlist[l]) == 0 && diameter[l] > 0.0)
            {
                if (nominee < 0.0)
                {
                    anchor = l;
                    nominee = diameter[l];
                }
                else
                {
                    if (diameter[l] < nominee)
                    {
                        anchor = l;
                        nominee = diameter[l];
                    }
                }
            }
        }
        if (nominee < 0.0)
            break;
        cardinality++;
        anchor = shortidlist[anchor];
/* Here anchor has been replaced with a sequence number of the element to be 
added to the candidate cluster. */
        SetBit(clusterbit, anchor);
        for (int l=0; l<lmax; l++)
        {
            if (TestBit(clusterbit, shortidlist[l]) != 0 || diameter[l] < 0.0)
                continue;
            cancer = -1;
            for (int m=0; m<del; m++)
            {
                if (frame[anchor][m] < 0 || frame[anchor][m] > shortidlist[l])
                break;
                if (frame[anchor][m] == shortidlist[l])
                {
                    cancer = m;
                    break;
                }
            }
            if (cancer < 0)
                diameter[l] = -1.0;
            else
            {
                if (diameter[l] < rmsd[anchor][cancer])
                    diameter[l] = rmsd[anchor][cancer];
            }
/* Update diameter. As long as an element is outside the candidate cluster, the
maximum value of distances from it to all elements in the candidate cluster in-
creases monotonously during the growing of the candidate cluster. After one ele-
ment was added to the candidate cluster, the maximum value of distances from one
element outside the candidate cluster to all elements in the candidate cluster 
should be the larger one between the distance from the element outside the can-
didate cluster to the latest member of the candidate cluster and the previous 
maximum value of distances from the element outside the candidate cluster to all
elements in the candidate cluster. */
        }
    }
    return cardinality;
/* The output of this function is the size of the candidate cluster. */
}

/* frame is a compacted matrix. It stores the sequence numbers of elements that 
are within threshold towards each element. Its width is del. rmsd is a compacted
matrix. It stores the distances smaller than threshold according to the sequence
numbers. Its width is del. Before growing the candidate cluster, array diameter 
can be viewed as one line of rmsd. During growing the candidate cluster, 
diameter keeps updating since it stores the maximum value of distances from each
element outside the candidate cluster to all elements in the candidate cluster. 
Its size is del. seqseed is the sequence number of the element inside all un-
clustered elements that acts as a starting point of the candidate cluster. 
indexbit is a sparse bit-mask that contains one for elements that have been 
clustered before the current iteration and zero for other elements. It remains 
unchanged during the execution of this function. remainder is the number of ele-
ments that have not been clustered. clusterbit is a sparse bit-mask that con-
tains one for elements that have been added to the growing candidate cluster and
zero for other elements. clusterbit can be viewed as the output of this function
and will be printed to a text file after certain transformation. clusterbitsize 
is the size of indexbit or clusterbit. toc is the threshold of clustering, which
is larger than any value in diameter. */
void MonoClustering (int **frame, float **rmsd, float *restrict diameter, int seqseed, unsigned *indexbit, int remainder, unsigned *restrict clusterbit, int clusterbitsize, int del, float toc)
{
    int cardinality, anchor, cancer;
    float nominee;
    #pragma omp parallel for
    for (int l=0; l<clusterbitsize; l++)
    {
        clusterbit[l] = 0;
    }
    SetBit(clusterbit, seqseed);
/* Initialize the bit-mask clusterbit. */
    #pragma omp parallel for
    for (int l=0; l<del; l++)
    {
        if (TestBit(indexbit, frame[seqseed][l]) == 0)
            diameter[l] = rmsd[seqseed][l];
        else
            diameter[l] = -1.0;
    }
    cardinality = 1;
    while (cardinality < remainder)
    {
        nominee = -1.0;
        #pragma omp parallel for reduction(max:nominee)
        for (int l=0; l<del; l++)
        {
            if (diameter[l] > 0.0)
                nominee = diameter[l];
        }
        if (nominee < 0.0)
            break;
        nominee = toc + 1.0;
        #pragma omp parallel for reduction(min:nominee)
        for (int l=0; l<del; l++)
        {
            if (diameter[l] > 0.0 && diameter[l] < nominee)
                nominee = diameter[l];
        }
        anchor = del;
        #pragma omp parallel for reduction(min:anchor)
        for (int l=0; l<del; l++)
        {
            if (diameter[l] == nominee)
                anchor = l;
        }
        diameter[anchor] = -1.0;
        cardinality++;
        anchor = frame[seqseed][anchor];
/* Here anchor has been replaced with a sequence number of the element to be 
added to the candidate cluster. */
        SetBit(clusterbit, anchor);
        #pragma omp parallel for private(cancer)
        for (int l=0; l<del; l++)
        {
            if (diameter[l] < 0.0)
                continue;
            cancer = -1;
            for (int m=0; m<del; m++)
            {
                if (frame[anchor][m] < 0)
                    break;
                if (frame[anchor][m] == frame[seqseed][l])
                {
                    cancer = m;
                    break;
                }
            }
            if (cancer < 0)
                diameter[l] = -1.0;
            else
            {
                if (diameter[l] < rmsd[anchor][cancer])
                    diameter[l] = rmsd[anchor][cancer];
            }
/* Update diameter. As long as an element is outside the candidate cluster, the
maximum value of distances from it to all elements in the candidate cluster in-
creases monotonously during the growing of the candidate cluster. After one ele-
ment was added to the candidate cluster, the maximum value of distances from one
element outside the candidate cluster to all elements in the candidate cluster 
should be the larger one between the distance from the element outside the can-
didate cluster to the latest member of the candidate cluster and the previous 
maximum value of distances from the element outside the candidate cluster to all
elements in the candidate cluster. */
        }
    }
}

void PrintCitation()
{
    printf("If you want to use this program in any of your published work, please cite the following papers:\n");
    printf("1. Laurie J. Heyer, Semyon Kruglyak, and Shibu Yooseph, Exploring Expression Data: Identification and Analysis of Coexpressed Genes, Genome Research, 1999, 9, 1106-1105. DOI:10.1101/gr.9.11.1106.\n");
    printf("2. Anthony Danalis, Collin McCurdy, and Jeffrey S. Vetter, Efficient Quality Threshold Clustering for Parallel Architectures, 2012 IEEE 26th International Parallel and Distributed Processing Symposium, Shanghai, China, 2012, pp. 1068-1079. DOI: 10.1109/IPDPS.2012.99.\n");
}

int main (int argc, char *argv[])
{
    int numberofelements = -1;
    float thresholdofclustering = -1.0;
    char *outputtext;
    int opt = 0;
    static struct option long_options[] =
    {
        {"number",    required_argument, NULL, 'n'},
        {"threshold", required_argument, NULL, 't'},
        {"output",    required_argument, NULL, 'o'}
    };
    int long_index = 0;
/* Parse command line options at first. */
    while ((opt = getopt_long(argc, argv, "n:t:o:", long_options, &long_index)) != -1)
    {
        switch (opt)
        {
            case 'n':
                numberofelements = atoi(optarg);
                break;
            case 't':
                thresholdofclustering = atof(optarg);
                break;
            case 'o':
                outputtext = (char *)malloc((strlen(optarg)+1)*sizeof(char));
                if (outputtext == NULL)
                {
                    fprintf(stderr, "Memory allocation failure in obtaining the name of the output file.\n");
                    exit(1);
                }
                outputtext[strlen(optarg)] = '\0';
                strcpy(outputtext, optarg);
                break;
            default:
                PrintUsage();
                exit(1);
        }
    }
    if (numberofelements == -1 || thresholdofclustering == -1.0)
    {
        PrintUsage();
        exit(1);
    }
    int rows = numberofelements;
    int cols = numberofelements;
    int order, counter, delta, cancer, available;
    float d = thresholdofclustering;
    float (*R)[cols] = AllocFloatArray(rows, cols);
    if (R == NULL)
    {
        fprintf(stderr, "Memory allocation failure in creating matrix R.\n");
        exit(1);
    }
    ReadFloatArray(rows, cols, R);
    int *interaction;
    interaction = (int *)malloc(rows*sizeof(int));
    if (interaction == NULL)
    {
        fprintf(stderr, "Memory allocation failure in creating array interaction.\n");
        exit(1);
    }
/* The array interaction will be used to store the number of elements that are 
within threshold towards each element respectively. Keep in mind that the main 
diagonal of matrix R consists of 0 only.*/
    #pragma omp parallel for private(counter)
    for (int i=0; i<numberofelements; i++)
    {
        counter = 0;
        for (int j=0; j<numberofelements; j++)
        {
            if (R[i][j] <= d)
                counter++;
        }
        interaction[i] = counter - 1;
    }
/* delta will be set at the maximum value in the array interaction. */
    delta = 0;
    #pragma omp parallel for reduction(max:delta)
    for (int i=0; i<numberofelements; i++)
    {
        if (interaction[i] > delta)
            delta = interaction[i];
    }
    if (delta == 0)
    {
        printf("The threshold specified by the user is smaller than the minimum value of pairwise distance in rmsd.dat file. Each element can form a one-membered cluster by itself while the result has no practical value.\n");
        free(interaction);
        free(R);
        exit(1);
    }
    rows = numberofelements;
    cols = delta;
/* B1 is a compacted matrix. It stores the sequence numbers of elements that are
within threshold towards each element. Its width is delta. */
    int (*B1)[cols] = AllocIntArray(rows, cols);
    if (B1 == NULL)
    {
        fprintf(stderr, "Memory allocation failure in creating matrix B1.\n");
        exit(1);
    }
/* B2 is a compacted matrix. It stores the distances smaller than threshold ac-
cording to the sequence numbers. Its width is delta. */
    float (*B2)[cols] = AllocFloatArray(rows, cols);
    if (B2 == NULL)
    {
        fprintf(stderr, "Memory allocation failure in creating matrix B2.\n");
        exit(1);
    }
    #pragma omp parallel for private(counter)
    for (int i=0; i<numberofelements; i++)
    {
        counter = 0;
        for (int j=0; j<numberofelements; j++)
        {
/*The distance from one element to itself is zero, which is absolutely smaller 
than threshold and should not be counted.*/
            if (j == i)
                continue;
            else
            {
                if (R[i][j] <= d)
                {
                    B1[i][counter] = j;
                    counter++;
                }
            }
        }
/* When the number of elements that are within threshold towards one element is 
less than delta, indexes in excess will be set at -1. */
        for (int j=counter; j<delta; j++)
        {
            B1[i][j] = -1;
        }
    }
    #pragma omp parallel for private(counter)
    for (int i=0; i<numberofelements; i++)
    {
        counter = 0;
        for (int j=0; j<numberofelements; j++)
        {
/*The distance from one element to itself is zero, which is absolutely smaller 
than threshold and should not be counted.*/
            if (j == i)
                continue;
            else
            {
                if (R[i][j] <= d)
                {
                    B2[i][counter] = R[i][j];
                    counter++;
                }
            }
        }
/* When the number of elements that are within threshold towards one element is 
less than delta, distances in excess will be set at -1.0. */
        for (int j=counter; j<delta; j++)
        {
            B2[i][j] = -1.0;
        }
    }
    free(R);
/* The original matrix will not come into use. Instead, compacted matrices B1 
and B2 will come into use. */
    int *I, *work, *capacity;
    unsigned *S;
    I = (int *)malloc(rows*sizeof(int));
    if (I == NULL)
    {
        fprintf(stderr, "Memory allocation failure in creating array I.\n");
        exit(1);
    }
/* The array "I" stores currently unclustered elements after each iteration. */
    available = omp_get_max_threads();
    work = (int *)malloc(2*available*sizeof(int));
    if (work == NULL)
    {
        fprintf(stderr, "Memory allocation failure in creating array work.\n");
        exit(1);
    }
    capacity = (int *)malloc(rows*sizeof(int));
    if (capacity == NULL)
    {
        fprintf(stderr, "Memory allocation failure in creating array capacity.\n");
        exit(1);
    }
/* The array capacity stores the sizes of candidate clusters. The largest va-
lue in the array capacity corresponds to the next cluster. */
    if (rows%sizeof(unsigned) == 0)
        order = rows / sizeof(unsigned);
    else
        order = rows / sizeof(unsigned) + 1;
    S = (unsigned *)malloc(order*sizeof(unsigned));
    if (S == NULL)
    {
        fprintf(stderr, "Memory allocation failure in creating array S.\n");
        exit(1);
    }
/* S is a sparse bit-mask that contains one for elements that have been cluster-
ed before the current iteration and zero for other elements. */
    #pragma omp parallel for
    for (int i=0; i<numberofelements; i++)
    {
        I[i] = i;
    }
    #pragma omp parallel for
    for (int i=0; i<order; i++)
    {
        S[i] = 0;
    }
    int unclustered = numberofelements;
    int maxcardinality, sum, ideal, temp, fragment, record;
    float nominee;
    unsigned *SP;
    int *icache;
    float *dcache;
    int **aB1;
    float **aB2;
    aB1 = ConvertIntMatrix(&B1[0][0], rows, cols);
    aB2 = ConvertFloatMatrix(&B2[0][0], rows, cols);
/* B1 and B2 cannot be easily used as parameters in functions. aB1 and aB2 can 
be used as parameters in functions. */
    FILE *fp;
    fp = fopen(outputtext, "w");
    while (unclustered > 0)
    {
/* unclustered is the number of elements that have not been clustered. */
        if (unclustered == 1)
        {
            SetBit(S, I[0]);
            fprintf(fp, "%d\n", I[0]);
            break;
        }
        else
        {
            if (unclustered > available && available > 1)
            {
                sum = 0;
                for (int i=0; i<unclustered; i++)
                {
                    sum += interaction[I[i]];
                }
/* Some elements in the array interaction can be zero. */
                sum += unclustered;
                ideal = sum / available;
                work[0] = 0;
                #pragma omp parallel for
                for (int i=1; i<2*available; i++)
                {
                    work[i] = -1;
                }
/* We start allocating per-thread starting and ending indices. We naively assu-
me the workload for each unclustered element is proportional to the number of 
elements that are within threshold towards it. */
                counter = available;
                if (sum % available == 0)
                {
                    for (int i=0; i<available; i++)
                    {
                        if (work[2*i] >= unclustered)
                        {
                            work[2*i] = -1;
                            counter = i;
                            break;
                        }
/* Some elements in the array interaction can be zero. */
                        temp = interaction[I[work[2*i]]] + 1;
                        if (temp >= ideal)
                        {
                            work[2*i+1] = work[2*i];
                            if (i < available-1)
                                work[2*i+2] = work[2*i] + 1;
                        }
                        else
                        {
                            for (int j=1; temp<ideal; j++)
                            {
                                if (work[2*i]+j >= unclustered)
                                {
                                    record = j - 1;
                                    break;
                                }
/* Some elements in the array interaction can be zero. */
                                temp = temp + interaction[I[work[2*i]+j]] + 1;
                                record = j;
                            }
                            work[2*i+1] = work[2*i] + record;
                            if (i < available-1)
                                work[2*i+2] = work[2*i] + record + 1;
                        }
                    }
                }
                else
                {
                    for (int i=0; i<available; i++)
                    {
                        if (work[2*i] >= unclustered)
                        {
                            work[2*i] = -1;
                            counter = i;
                            break;
                        }
/* Some elements in the array interaction can be zero. */
                        temp = interaction[I[work[2*i]]] + 1;
                        if (temp > ideal)
                        {
                            work[2*i+1] = work[2*i];
                            if (i < available-1)
                                work[2*i+2] = work[2*i] + 1;
                        }
                        else
                        {
                            for (int j=1; temp<=ideal; j++)
                            {
                                if (work[2*i]+j >= unclustered)
                                {
                                    record = j - 1;
                                    break;
                                }
/* Some elements in the array interaction can be zero. */
                                temp = temp + interaction[I[work[2*i]+j]] + 1;
                                record = j;
                            }
                            work[2*i+1] = work[2*i] + record;
                            if (i < available-1)
                                work[2*i+2] = work[2*i] + record + 1;
                        }
                     }
                }
/* The naive allocation can leave no job for certain threads to do. In this ca-
se, we need to reallocate per-thread starting and ending indices. */
                while (counter < available)
                {
                    record = -1;
                    fragment = 0;
                    for (int i=0; i<counter; i++)
                    {
                        temp = 0;
                        for(int j=work[2*i]; j<=work[2*i+1]; j++)
/* Some elements in the array interaction can be zero. */
                            temp = temp + interaction[I[j]] + 1;
                        if (temp > fragment)
                        {
                            record = i;
                            fragment = temp;
                        }
                    }
                    if (record == -1)
                    {
                        fprintf(stderr, "Error in allocating per-thread starting and ending indices, which indicates the user might have forgotten to set the OMP_NUM_THREADS environment variable.\n");
                        exit(1);
                    }
                    if (work[2*record+1] == work[2*record])
                    {
                        record = -1;
                        fragment = 0;
                        for (int i=0; i<counter; i++)
                        {
                            if (work[2*i+1]-work[2*i]+1 > fragment)
                            {
                                record = i;
                                fragment = work[2*i+1] - work[2*i] + 1;
                            }
                        }
                        if (record == -1)
                        {
                            fprintf(stderr, "Error in allocating per-thread starting and ending indices.\n");
                            exit(1);
                        }
                        if (fragment == 1)
/* In the threads that have job to do, each thread is only in charge of one 
starting point. There is no need to do reallocation in this case. */
                            break;
                    }
                    if (work[2*counter] != -1)
                    {
                        fprintf(stderr, "Error in allocating per-thread starting and ending indices.\n");
                        exit(1);
                    }
                    work[2*counter] = work[2*counter-1];
                    work[2*counter+1] = work[2*counter-1];
                    for (int i=record+1; i<counter; i++)
                    {
                        work[2*i] -= 1;
                        work[2*i+1] -= 1;
                    }
                    work[2*record+1] -= 1;
                    counter++;
                }
/* counter is equal to available before OpenMP calculations. */
                #pragma omp parallel for private(SP, temp) schedule(static)
                for (int i=0; i<counter; i++)
                {
                    SP = (unsigned *)malloc(order*sizeof(unsigned));
/* order is the size of the sparse bit-mask S. The size of SP is the same as 
that of S. */
                    if (SP == NULL)
                    {
                        fprintf(stderr, "Memory allocation failure in creating array SP to be used by MultiClustering().\n");
                        exit(1);
                    }
                    int localrow, localmax;
                    localrow = work[2*i+1] - work[2*i] + 1;
/* In each thread, private variable localrow is the number of assigned elements 
that acts as starting points of candidate clusters. */
                    localmax = 0;
/* In each thread, private variable localmax is the maximum value of elements 
that are within threshold towards each element assigned to one thread. Thus, it 
is smaller than or equal to delta and greater than or equal to the size of clus-
ters to be formed. */
                    for (int j=0; j<localrow; j++)
                    {
                        temp = 0;
                        for (int k=0; k<delta; k++)
                        {
                            if (B1[I[work[2*i]+j]][k] < 0)
                                break;
                            if (TestBit(S, B1[I[work[2*i]+j]][k]) == 0)
                                temp++;
                            if (temp == interaction[I[work[2*i]+j]])
                                break;
                        }
/* Update array interaction. */
                        interaction[I[work[2*i]+j]] = temp;
                        if (temp > localmax)
                            localmax = temp;
                    }
/* multiicache can be viewed as a slice of B1 where only elements assigned to 
one thread are included. It stores the sequence numbers of elements that are wi-
thin threshold towards each element assigned to one thread. Its width is 
localmax. */
                    int (*multiicache)[localmax] = AllocIntArray(localrow, localmax);
                    if (multiicache == NULL)
                    {
                        fprintf(stderr, "Memory allocation failure in creating matrix multiicache.\n");
                        exit(1);
                    }
                    float (*multidcache)[localmax] = AllocFloatArray(localrow, localmax);
                    if (multidcache == NULL)
                    {
                        fprintf(stderr, "Memory allocation failure in creating matrix multidcache.\n");
                        exit(1);
                    }
                    for (int j=0; j<localrow; j++)
                    {
                        temp = 0;
                        for (int k=0; k<delta; k++)
                        {
                            if (B1[I[work[2*i]+j]][k] < 0)
                                break;
                            if (TestBit(S, B1[I[work[2*i]+j]][k]) == 0)
                            {
                                multiicache[j][temp] = B1[I[work[2*i]+j]][k];
                                multidcache[j][temp] = B2[I[work[2*i]+j]][k];
                                temp++;
                            }
                        }
                        for (int k=temp; k<localmax; k++)
                        {
                            multiicache[j][k] = -1;
                        }
                        for (int k=temp; k<localmax; k++)
                        {
                            multidcache[j][k] = -1.0;
                        }
                    }
/* Right now multidcache can be viewed as a slice of B2 where only elements as-
signed to one thread are included. It stores the distances smaller than thre-
shold according to the sequence numbers where one edge of the distance belongs 
to elements assigned to one thread. After a while it will keep updating. Its 
width is localmax. */
                    int **amultiicache;
                    float **amultidcache;
                    amultiicache = ConvertIntMatrix(&multiicache[0][0], localrow, localmax);
                    amultidcache = ConvertFloatMatrix(&multidcache[0][0], localrow, localmax);
/* multiicache and multidcache cannot be easily used as parameters in functions.
amultiicache and amultidcache can be used as parameters in functions. */
                    MultiClustering(aB1, aB2, amultiicache, amultidcache, I, localrow, work[2*i], unclustered, SP, order, delta, localmax, capacity);
                    free(SP);
                    SP = NULL;
                    FreeConvertIntMatrix(amultiicache);
                    FreeConvertFloatMatrix(amultidcache);
                    free(multiicache);
                    free(multidcache);
                    multiicache = NULL;
                    multidcache = NULL;
                    amultiicache = NULL;
                    amultidcache = NULL;
                }
            }
/* Normally, the number of unclustered elements can be smaller than the number 
of threads near the end of calculation. Another situation is that the user sets 
the default number of threads to use in parallel regions at 1 or the user uses a
chip with only one core, which should be avoided if the user is dealing with 
realistic data. */
            else
            {
                #pragma omp parallel for private(SP, icache, dcache, temp) schedule(static)
                for (int i=0; i<unclustered; i++)
                {
                    SP = (unsigned *)malloc(order*sizeof(unsigned));
                    if (SP == NULL)
                    {
                        fprintf(stderr, "Memory allocation failure in creating array SP to be used by EndingClustering().\n");
                        exit(1);
                    }
                    temp = 0;
                    for (int k=0; k<delta; k++)
                    {
                        if (B1[I[i]][k] < 0)
                            break;
                        if (TestBit(S, B1[I[i]][k]) == 0)
                            temp++;
                        if (temp == interaction[I[i]])
                            break;
                    }
                    interaction[I[i]] = temp;
                    icache = (int *)malloc(temp*sizeof(int));
                    if (icache == NULL)
                    {
                        fprintf(stderr, "Memory allocation failure in creating array icache to be used by EndingClustering().\n");
                        exit(1);
                    }
                    dcache = (float *)malloc(temp*sizeof(float));
                    if (dcache == NULL)
                    {
                        fprintf(stderr, "Memory allocation failure in creating array dcache to be used by EndingClustering().\n");
                        exit(1);
                    }
                    temp = 0;
                    for (int k=0; k<delta; k++)
                    {
                        if (B1[I[i]][k] < 0)
                            break;
                        if (TestBit(S, B1[I[i]][k]) == 0)
                        {
                            icache[temp] = B1[I[i]][k];
                            dcache[temp] = B2[I[i]][k];
                            temp++;
                        }
                        if (temp == interaction[I[i]])
                            break;
                    }
                    capacity[i] = EndingClustering(aB1, aB2, icache, dcache, I[i], unclustered, SP, order, delta, temp);
                    free(SP);
                    free(dcache);
                    SP = NULL;
                    dcache = NULL;
                }
            }
            maxcardinality = 0;
            #pragma omp parallel for reduction(max:maxcardinality)
            for (int i=0; i<unclustered; i++)
            {
                if (capacity[i] > maxcardinality)
                    maxcardinality = capacity[i];
            }
/* The original quality threshold clustering algorithm does not specify what to 
do when more than one cluster's size reaches maximum value in one iteration. 
Here I arbitrarily decide to output the cluster whose sequence number of the 
starting point is smallest if such case occurs. */
            for (int i=0; i<unclustered; i++)
            {
                if (capacity[i] == maxcardinality)
                {
                    counter = i;
                    break;
                }
            }
            SP = (unsigned *)malloc(order*sizeof(unsigned));
            if (SP == NULL)
            {
                fprintf(stderr, "Memory allocation failure in creating array SP to be used by MonoClustering().\n");
                exit(1);
            }
            dcache = (float *)malloc(delta*sizeof(float));
            if (dcache == NULL)
            {
                fprintf(stderr, "Memory allocation failure in creating array dcache to be used by MonoClustering().\n");
                exit(1);
            }
            MonoClustering(aB1, aB2, dcache, I[counter], S, unclustered, SP, order, delta, thresholdofclustering);
            free(dcache);
            dcache = NULL;
/* output */
            fprintf(fp, "%d", I[counter]);
            for (int i=0; i<rows; i++)
            {
                if (TestBit(SP, i) != 0 && i != I[counter])
                    fprintf(fp, ",%d", i);
            }
            fprintf(fp, "\n");
/* update S */
            #pragma omp parallel for
            for (int i=0; i<order; i++)
            {
                S[i] += SP[i];
            }
/* update dense array I and unclustered */
            for (int i=0; i<rows; i++)
            {
                if (TestBit(SP, i) != 0)
                {
                    for (int j=0; j<unclustered; j++)
                    {
                        if (I[j] == i)
                        {
                            for (int k=j; k<unclustered-1; k++)
                                I[k] = I[k+1];
                            I[unclustered-1] = -1;
                            unclustered--;
                            break;
                        }
                    }
                }
            }
            free(SP);
            SP = NULL;
        }
    }
    fclose(fp);
    free(I);
    free(S);
    FreeConvertIntMatrix(aB1);
    FreeConvertFloatMatrix(aB2);
    free(B1);
    free(B2);
    free(interaction);
    free(work);
    free(capacity);
    PrintCitation();
    return 0;
}
